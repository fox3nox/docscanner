<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DocScanner – Bild → PDF (lokal im Browser)</title>
  <style>
    :root{--bg:#0f172a;--panel:#111827;--text:#e5e7eb;--muted:#9ca3af;--accent:#22d3ee;--border:#1f2937}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    header{padding:16px 20px;border-bottom:1px solid var(--border);display:flex;gap:14px;align-items:center}
    header h1{font-size:18px;margin:0}
    header small{color:var(--muted)}
    main{display:grid;grid-template-columns:380px 1fr;gap:16px;padding:16px;max-width:1400px;margin:0 auto}
    @media (max-width: 980px){ main{grid-template-columns:1fr}}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;overflow:hidden}
    .card header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--border)}
    .card header h2{margin:0;font-size:15px}
    .card .content{padding:14px}
    .hint{color:var(--muted);font-size:12px;margin-top:8px}
    input[type="file"]{display:none}
    .drop{border:1px dashed var(--border);border-radius:10px;padding:20px;text-align:center;background:#0b1220}
    .drop.drag{outline:2px dashed var(--accent);outline-offset:-6px}
    .btn{background:#0b5;cursor:pointer;border:0;color:white;border-radius:10px;padding:10px 14px;font-weight:600}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.secondary{background:#334155;color:#e5e7eb}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    canvas{max-width:100%;background:#0b1220;border:1px solid var(--border);border-radius:10px}
    .controls{display:grid;gap:10px}
    label{font-size:13px;color:#cbd5e1}
    select, input[type="number"], input[type="range"], input[type="checkbox"]{width:100%;background:#0b1220;border:1px solid var(--border);color:var(--text);padding:8px;border-radius:8px}
    .pill{display:inline-block;padding:4px 8px;border:1px solid var(--border);border-radius:999px;color:#93c5fd;background:#0b1220;font-size:12px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .spacer{height:8px}
    .footer{display:flex;gap:8px;flex-wrap:wrap}
    .corner{position:absolute;width:16px;height:16px;border-radius:50%;background:#22d3ee;border:2px solid #0e7490;cursor:grab;transform:translate(-50%,-50%)}
    .stage{position:relative;display:inline-block}
    .badge{font-size:12px;color:#a7f3d0;background:#064e3b;border:1px solid #065f46;border-radius:8px;padding:4px 8px}
  </style>
</head>
<body>
  <header>
    <h1>DocScanner</h1>
    <small>Alles passiert lokal im Browser. Nichts wird hochgeladen.</small>
  </header>

  <main>
    <section class="card">
      <header><h2>1) Bild(e) laden</h2><span class="pill" id="opencvStatus">OpenCV lädt…</span></header>
      <div class="content">
        <div class="drop" id="dropzone">
          <p><strong>JPEG/PNG hierher ziehen</strong> oder</p>
          <button class="btn secondary" id="pickBtn">Datei auswählen / Foto aufnehmen</button>
          <!-- capture="environment" öffnet am iPhone direkt die Kamera -->
          <input id="fileInput" type="file" accept="image/*" capture="environment" multiple />
          <p class="hint">Tipps: Foto senkrecht & ausreichend Licht. Mehrere Bilder = mehrseitiges PDF.</p>
        </div>
        <div class="spacer"></div>
        <div class="controls">
          <div class="grid2">
            <div>
              <label for="pageSize">PDF-Seite</label>
              <select id="pageSize">
                <option value="A4">A4 (210×297 mm)</option>
                <option value="Letter">US Letter (8.5×11 in)</option>
                <option value="Fit">Am Inhalt ausrichten (keine Skalierung)</option>
              </select>
            </div>
            <div>
              <label for="dpi">Zielauflösung (DPI)</label>
              <input id="dpi" type="number" min="72" max="600" step="1" value="300" />
            </div>
          </div>
          <div class="grid2">
            <div>
              <label for="threshold">Kontrast/Schwarzweiß</label>
              <input id="threshold" type="range" min="0" max="40" step="1" value="12" />
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <input id="bw" type="checkbox" checked />
              <label for="bw">S/W verbessern (Scanner-Effekt)</label>
            </div>
          </div>
          <div class="row">
            <button class="btn" id="btnProcess" disabled>Automatisch zuschneiden</button>
            <button class="btn secondary" id="btnManual" disabled>Ecken manuell anpassen</button>
            <button class="btn secondary" id="btnReset" disabled>Zurücksetzen</button>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <header><h2>2) Vorschau & PDF</h2><span class="badge" id="pagesBadge">0 Seite(n)</span></header>
      <div class="content">
        <div class="row" style="align-items:flex-start">
          <div>
            <div><strong>Original</strong></div>
            <canvas id="orig" width="0" height="0"></canvas>
          </div>
          <div>
            <div style="display:flex;align-items:center;gap:10px">
              <strong>Ergebnis</strong> <small class="hint" id="detectInfo"></small>
            </div>
            <div class="stage" id="stage">
              <canvas id="result" width="0" height="0"></canvas>
              <!-- draggable corners injected here -->
            </div>
          </div>
        </div>
        <div class="spacer"></div>
        <div class="footer">
          <button class="btn" id="btnAdd" disabled>Seite zum PDF hinzufügen</button>
          <button class="btn secondary" id="btnClear" disabled>PDF-Seiten leeren</button>
          <button class="btn" id="btnDownload" disabled>PDF herunterladen</button>
        </div>
      </div>
    </section>
  </main>

  <!-- Libraries (from public CDNs) -->
  <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

  <script>
    // --- State ---
    let cvReady = false;
    let currentImage = null;      // HTMLImageElement
    let currentMat = null;        // cv.Mat of original
    let warpedMat = null;         // cv.Mat after perspective
    let manualMode = false;
    let quadPts = null;           // [[x,y],...]
    let pdfPages = [];            // array of {imgData, widthPx, heightPx}
    const $ = sel => document.querySelector(sel);

    const el = {
      opencvStatus: $('#opencvStatus'),
      drop: $('#dropzone'),
      pickBtn: $('#pickBtn'),
      fileInput: $('#fileInput'),
      pageSize: $('#pageSize'),
      dpi: $('#dpi'),
      threshold: $('#threshold'),
      bw: $('#bw'),
      btnProcess: $('#btnProcess'),
      btnManual: $('#btnManual'),
      btnReset: $('#btnReset'),
      btnAdd: $('#btnAdd'),
      btnClear: $('#btnClear'),
      btnDownload: $('#btnDownload'),
      pagesBadge: $('#pagesBadge'),
      detectInfo: $('#detectInfo'),
      orig: $('#orig'),
      result: $('#result'),
      stage: $('#stage')
    };

    function setButtons({loaded=false, haveResult=false, havePages=false}){
      el.btnProcess.disabled = !loaded;
      el.btnManual.disabled  = !loaded;
      el.btnReset.disabled   = !loaded;
      el.btnAdd.disabled     = !haveResult;
      el.btnClear.disabled   = !havePages;
      el.btnDownload.disabled= !havePages;
    }

    // OpenCV boot
    function onOpenCvReady(){
      cvReady = true;
      el.opencvStatus.textContent = 'OpenCV bereit';
      el.opencvStatus.style.background = '#052e42';
      el.opencvStatus.style.borderColor = '#0ea5e9';
    }
    window.Module = { onRuntimeInitialized: onOpenCvReady };

    // File/select handling
    function bindFileInput(){
      el.pickBtn.addEventListener('click', ()=> el.fileInput.click());
      el.fileInput.addEventListener('change', (e)=> handleFiles(e.target.files));

      ;['dragenter','dragover'].forEach(evt => el.drop.addEventListener(evt,(e)=>{e.preventDefault();el.drop.classList.add('drag')}));
      ;['dragleave','drop'].forEach(evt => el.drop.addEventListener(evt,(e)=>{e.preventDefault();el.drop.classList.remove('drag')}));
      el.drop.addEventListener('drop', (e)=> handleFiles(e.dataTransfer.files));
    }

    async function handleFiles(fileList){
      if (!fileList || !fileList.length) return;
      const files = [...fileList].filter(f=> f.type.startsWith('image/'));
      if (!files.length) return alert('Bitte Bilddateien auswählen.');
      await loadImage(files[0]);
      setButtons({loaded:true, haveResult:false, havePages: pdfPages.length>0});
    }

    function loadImage(file){
      return new Promise((resolve,reject)=>{
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = ()=>{
          currentImage = img;
          drawToCanvas(el.orig, img);
          if (currentMat) currentMat.delete();
          currentMat = cv.imread(el.orig);
          el.detectInfo.textContent = '';
          quadPts = null;
          if (warpedMat){ warpedMat.delete(); warpedMat = null; }
          clearCorners();
          setButtons({loaded:true, haveResult:false, havePages: pdfPages.length>0});
          resolve();
        };
        img.onerror = reject;
        img.src = url;
      });
    }

    function drawToCanvas(canvas, img){
      const maxW = 1200;
      const scale = Math.min(1, maxW / img.width);
      canvas.width  = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    }

    function detectDocumentQuad(srcMat){
      const maxSide = 1000;
      const ratio = Math.min(1, maxSide / Math.max(srcMat.cols, srcMat.rows));
      const small = new cv.Mat();
      cv.resize(srcMat, small, new cv.Size(0,0), ratio, ratio, cv.INTER_AREA);

      let gray = new cv.Mat(); cv.cvtColor(small, gray, cv.COLOR_RGBA2GRAY, 0);
      let blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
      let edges = new cv.Mat(); cv.Canny(blur, edges, 75, 200);

      let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5,5));
      cv.dilate(edges, edges, kernel);
      cv.erode(edges, edges, kernel);

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      let best = null;
      for (let i=0;i<contours.size();i++){
        const c = contours.get(i);
        const peri = cv.arcLength(c, true);
        const approx = new cv.Mat();
        cv.approxPolyDP(c, approx, 0.02 * peri, true);
        if (approx.rows === 4){
          const area = cv.contourArea(approx);
          if (area > 3_000){
            if (!best || area > best.area) best = {approx, area};
            else approx.delete();
          } else approx.delete();
        } else approx.delete();
        c.delete();
      }
      edges.delete(); kernel.delete(); blur.delete(); gray.delete(); hierarchy.delete();

      if (!best) { contours.delete(); small.delete(); return null; }
      const pts = [];
      for (let i=0;i<4;i++){
        const pt = best.approx.intPtr(i);
        pts.push([pt[0] / ratio, pt[1] / ratio]);
      }
      best.approx.delete(); contours.delete(); small.delete();
      return orderPoints(pts);
    }

    function orderPoints(pts){
      const sum = pts.map(p=> p[0]+p[1]);
      const diff = pts.map(p=> p[0]-p[1]);
      const tl = pts[sum.indexOf(Math.min(...sum))];
      const br = pts[sum.indexOf(Math.max(...sum))];
      const tr = pts[diff.indexOf(Math.max(...diff))];
      const bl = pts[diff.indexOf(Math.min(...diff))];
      return [tl,tr,br,bl];
    }

    function warpByQuad(srcMat, quad, enhanceBW=true, threshStrength=12){
      const [tl,tr,br,bl] = quad;
      const widthTop = Math.hypot(tr[0]-tl[0], tr[1]-tl[1]);
      const widthBottom = Math.hypot(br[0]-bl[0], br[1]-bl[1]);
      const maxWidth = Math.max(widthTop, widthBottom);
      const heightLeft = Math.hypot(bl[0]-tl[0], bl[1]-tl[1]);
      const heightRight = Math.hypot(br[0]-tr[0], br[1]-tr[1]);
      const maxHeight = Math.max(heightLeft, heightRight);
      const dstW = Math.round(maxWidth);
      const dstH = Math.round(maxHeight);

      const srcTri = cv.matFromArray(4,1, cv.CV_32FC2, new Float32Array([
        tl[0],tl[1], tr[0],tr[1], br[0],br[1], bl[0],bl[1]
      ]));
      const dstTri = cv.matFromArray(4,1, cv.CV_32FC2, new Float32Array([
        0,0, dstW,0, dstW,dstH, 0,dstH
      ]));
      const M = cv.getPerspectiveTransform(srcTri, dstTri);
      const dst = new cv.Mat();
      cv.warpPerspective(srcMat, dst, M, new cv.Size(dstW, dstH), cv.INTER_CUBIC, cv.BORDER_REPLICATE);

      srcTri.delete(); dstTri.delete(); M.delete();

      if (enhanceBW){
        let g = new cv.Mat(); cv.cvtColor(dst, g, cv.COLOR_RGBA2GRAY, 0);
        let t = new cv.Mat();
        const blockSize = 15 + (threshStrength|0);
        cv.adaptiveThreshold(g, t, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize|1, 2);
        cv.cvtColor(t, dst, cv.COLOR_GRAY2RGBA, 0);
        g.delete(); t.delete();
      }
      return dst;
    }

    function matToCanvas(mat, canvas){ cv.imshow(canvas, mat); }
    function clearCorners(){ [...document.querySelectorAll('.corner')].forEach(el=> el.remove()); }

    function addCornerHandles(quad){
      clearCorners();
      quad.forEach((p, i)=>{
        const node = document.createElement('div');
        node.className = 'corner';
        node.dataset.index = i;
        node.title = 'Ziehen zum Anpassen';
        el.stage.appendChild(node);
        positionHandle(node, p[0], p[1]);
      });
      enableDrag();
    }

    function positionHandle(node, x, y){
      const rect = el.result.getBoundingClientRect();
      const scaleX = el.result.width / rect.width;
      const scaleY = el.result.height / rect.height;
      node.style.left = (x/scaleX) + 'px';
      node.style.top  = (y/scaleY) + 'px';
    }

    function readHandles(){
      const rect = el.result.getBoundingClientRect();
      const scaleX = el.result.width / rect.width;
      const scaleY = el.result.height / rect.height;
      const nodes = [...document.querySelectorAll('.corner')];
      return nodes.map(n=> [parseFloat(n.style.left)*scaleX, parseFloat(n.style.top)*scaleY]);
    }

    function enableDrag(){
      const stageRect = ()=> el.result.getBoundingClientRect();
      let active = null;
      function onDown(e){
        if (!e.target.classList.contains('corner')) return;
        active = e.target;
        active.style.cursor = 'grabbing';
        e.preventDefault();
      }
      function onMove(e){
        if (!active) return;
        const r = stageRect();
        const x = Math.max(0, Math.min(e.clientX - r.left, r.width));
        const y = Math.max(0, Math.min(e.clientY - r.top,  r.height));
        active.style.left = x + 'px';
        active.style.top  = y + 'px';
      }
      function onUp(){
        if (!active) return;
        active.style.cursor = 'grab';
        active = null;
      }
      document.addEventListener('pointerdown', onDown);
      document.addEventListener('pointermove', onMove);
      document.addEventListener('pointerup', onUp);
    }

    function processAuto(){
      if (!cvReady || !currentMat) return alert('Warte auf OpenCV oder lade zuerst ein Bild.');
      const quad = manualMode ? orderPoints(readHandles()) : detectDocumentQuad(currentMat);
      if (!quad){
        el.detectInfo.textContent = '⚠️ Kein Dokument zuverlässig erkannt. Manuell anpassen.';
        manualMode = true;
        const w = currentMat.cols, h = currentMat.rows;
        const fallback = [[20,20],[w-20,20],[w-20,h-20],[20,h-20]];
        const tmp = warpByQuad(currentMat, fallback, el.bw.checked, parseInt(el.threshold.value,10));
        if (warpedMat) warpedMat.delete();
        warpedMat = tmp;
        matToCanvas(warpedMat, el.result);
        addCornerHandles(fallback);
        setButtons({loaded:true, haveResult:true, havePages: pdfPages.length>0});
        return;
      }
      quadPts = quad;
      manualMode = false;
      const tmp = warpByQuad(currentMat, quad, el.bw.checked, parseInt(el.threshold.value,10));
      if (warpedMat) warpedMat.delete();
      warpedMat = tmp;
      el.detectInfo.textContent = '✓ Automatisch erkannt';
      matToCanvas(warpedMat, el.result);
      setButtons({loaded:true, haveResult:true, havePages: pdfPages.length>0});
    }

    function enterManual(){
      if (!currentMat) return;
      if (!quadPts){
        quadPts = [[20,20],[currentMat.cols-20,20],[currentMat.cols-20,currentMat.rows-20],[20,currentMat.rows-20]];
      }
      manualMode = true;
      const tmp = warpByQuad(currentMat, quadPts, el.bw.checked, parseInt(el.threshold.value,10));
      if (warpedMat) warpedMat.delete();
      warpedMat = tmp;
      matToCanvas(warpedMat, el.result);
      addCornerHandles(quadPts);
      el.detectInfo.textContent = 'Ecken ziehen und dann „Automatisch zuschneiden“ erneut drücken.';
      setButtons({loaded:true, haveResult:true, havePages: pdfPages.length>0});
    }

    function resetAll(){
      if (warpedMat){ warpedMat.delete(); warpedMat = null; }
      quadPts = null; manualMode = false;
      el.result.width = 0; el.result.height = 0;
      clearCorners();
      el.detectInfo.textContent = '';
      setButtons({loaded: !!currentMat, haveResult:false, havePages: pdfPages.length>0});
    }

    function reprocessIfNeeded(){
      if (!currentMat || !quadPts) return;
      const tmp = warpByQuad(currentMat, quadPts, el.bw.checked, parseInt(el.threshold.value,10));
      if (warpedMat) warpedMat.delete();
      warpedMat = tmp;
      matToCanvas(warpedMat, el.result);
    }

    function updateBadge(){ document.getElementById('pagesBadge').textContent = `${pdfPages.length} Seite(n)`; }

    function addToPdf(){
      if (!warpedMat) return;
      const tmpCanvas = document.createElement('canvas');
      cv.imshow(tmpCanvas, warpedMat);
      const dataUrl = tmpCanvas.toDataURL('image/jpeg', 0.92);
      pdfPages.push({ imgData: dataUrl, widthPx: tmpCanvas.width, heightPx: tmpCanvas.height });
      updateBadge();
      setButtons({loaded:!!currentMat, haveResult:!!warpedMat, havePages:true});
    }

    function clearPdf(){
      pdfPages = [];
      updateBadge();
      setButtons({loaded:!!currentMat, haveResult:!!warpedMat, havePages:false});
    }

    function downloadPdf(){
      if (!pdfPages.length) return;
      const { jsPDF } = window.jspdf;
      const dpi = Math.max(72, Math.min(600, parseInt(el.dpi.value,10) || 300));
      const sizes = { 'A4': { wPt: 595.28, hPt: 841.89 }, 'Letter': { wPt: 612, hPt: 792 } };
      const pageSel = el.pageSize.value;
      const first = pdfPages[0];
      let doc;
      if (pageSel === 'Fit'){
        const wPt = first.widthPx * 72 / dpi;
        const hPt = first.heightPx * 72 / dpi;
        doc = new jsPDF({ unit:'pt', format:[wPt, hPt]});
      } else {
        const {wPt,hPt} = sizes[pageSel];
        doc = new jsPDF({ unit:'pt', format:[wPt, hPt]});
      }

      pdfPages.forEach((p, idx)=>{
        if (idx>0) doc.addPage();
        let pageW = doc.internal.pageSize.getWidth();
        let pageH = doc.internal.pageSize.getHeight();
        const imgWpt = p.widthPx * 72 / dpi;
        const imgHpt = p.heightPx * 72 / dpi;
        const margin = 18;
        const scale = Math.min((pageW-2*margin)/imgWpt, (pageH-2*margin)/imgHpt);
        const w = imgWpt * scale, h = imgHpt * scale;
        const x = (pageW - w)/2, y = (pageH - h)/2;
        doc.addImage(p.imgData, 'JPEG', x, y, w, h);
      });
      doc.save('scan.pdf');
    }

    // Listeners
    function bindControls(){
      el.btnProcess.addEventListener('click', processAuto);
      el.btnManual.addEventListener('click', enterManual);
      el.btnReset.addEventListener('click', resetAll);
      el.threshold.addEventListener('input', reprocessIfNeeded);
      el.bw.addEventListener('change', reprocessIfNeeded);
      el.btnAdd.addEventListener('click', addToPdf);
      el.btnClear.addEventListener('click', clearPdf);
      el.btnDownload.addEventListener('click', downloadPdf);
    }

    bindFileInput(); bindControls();
    setButtons({loaded:false, haveResult:false, havePages:false});
  </script>
</body>
</html>
